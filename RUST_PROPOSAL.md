# Proposal: Porting `@spatial-engine/core` to Rust/Wasm

This document outlines the strategy to rewrite the core logic of `spatial-engine` in Rust, compiling to WebAssembly (WASM). The primary goal is to leverage Rust's performance and memory safety while **maintaining 100% API compatibility** with the existing TypeScript implementation. This ensures current users can upgrade with minimal to no code changes.

## 1. Objectives

- **Performance**: utilize Rust's optimizations (SIMD, predictable memory layout) for raycasting and octree traversal.
- **Zero GC**: Continue the Data-Oriented Design (DOD) philosophy. Rust's manual memory management maps naturally to the existing flat-array architecture.
- **Drop-in Replacement**: The public API (Classes, Methods, Types) must remain identical.
- **Shared Memory**: Support `SharedArrayBuffer` for the Lidar worker, just as the current implementation does.

## 2. Architecture

### 2.1. The Rust Crate (`spatial-engine-wasm`)
We will create a new Rust crate (likely inside `packages/core/rust` or a new package) that implements the core logic:
- `AABBPool`
- `RayPool`
- `OctreeNodePool`
- `Octree` (traversal, insertion, subdivision)
- `Raycasting` (slab method)

### 2.2. JS/TS Bridge (The "Wrapper" Layer)
Directly exposing WASM classes often results in a slightly "alien" API (e.g., explicit `.free()` calls, async loading). To maintain the *exact* TypeScript API, we will use a **TypeScript Wrapper Layer**.

**Current TS:**
```typescript
export class AABBPool {
  constructor(capacity: number) { ... }
  allocate(): number { ... }
}
```

**New Architecture:**
1. **Rust**: Implements `AABBPoolWasm`.
2. **TypeScript**: Keeps the `AABBPool` class but delegates logic to the Rust instance.

```typescript
// packages/core/src/aabb.ts (Modified)
import { AABBPoolWasm } from './wasm-pkg'; // Generated by wasm-pack

export class AABBPool {
  private wasmHandle: AABBPoolWasm;

  constructor(capacity: number) {
    this.wasmHandle = AABBPoolWasm.new(capacity);
  }

  allocate(): number {
    return this.wasmHandle.allocate();
  }

  // Expose WASM memory as Float32Array to maintain existing access patterns
  get buffer(): Float32Array {
    return getWasmMemoryView(this.wasmHandle.ptr, ...);
  }
}
```

### 2.3. Memory Management & Pools
The current system uses `Float32Array` pools. In the Rust port:
- The "Pools" will be allocated inside the WASM linear memory (basically a `Vec<f32>` in Rust).
- We will expose these memory regions to JavaScript as `Float32Array` views.
- **Benefit**: No data copying between JS and WASM. JS writes directly into the WASM memory view, Rust reads it instantly.

## 3. Implementation Strategy

### Phase 1: Setup & Tooling
1.  Initialize a Rust project within the monorepo.
2.  Configure `wasm-pack` to build the Rust code.
3.  Set up the build pipeline to generate the WASM binary and TS definitions.
4.  Solve the **WASM Initialization** challenge:
    - *Problem*: WASM usually loads asynchronously.
    - *Solution*: We will provide an async `init()` function that must be called once at app startup. The rest of the API remains synchronous. This is the only breaking change/refactor required for users (one line of code).

### Phase 2: Porting Data Structures
Port the pools first, as they are the foundation.
-   **`AABBPool` & `RayPool`**:
    -   Rust struct with a `Vec<f32>`.
    -   Expose methods: `allocate`, `release`, `set`, `get`.
    -   Expose raw memory pointer for JS views.

### Phase 3: Porting Algorithms
-   **`OctreeNodePool`**: Similar to other pools.
-   **`Octree`**:
    -   Port `insert`, `update`, `subdivide`.
    -   Port `raycast` and `queryBox`.
    -   *Optimization*: These are heavy loops. Rust will significantly outperform TS here.

### Phase 4: Threading & SharedArrayBuffer
-   Rust's `wasm-bindgen` has support for `SharedArrayBuffer` (via `wasm-bindgen-rayon` or manual atomics).
-   We can maintain the Lidar Worker logic by passing the WASM module's `SharedArrayBuffer` (memory) to the worker, just as we currently pass the JS `SharedArrayBuffer`.

## 4. Migration Plan for Users

1.  **Install**: Update `@spatial-engine/core`.
2.  **Initialize**: Add one line to their entry point:
    ```typescript
    import { initSpatialEngine } from '@spatial-engine/core';

    await initSpatialEngine(); // Loads WASM
    ```
3.  **Use**: Everything else works exactly as before.

## 5. Directory Structure

```text
packages/
  core/
    src/
      rust/          <-- New Rust source
        src/
          lib.rs     <-- Entry point
          aabb.rs
          octree.rs
        Cargo.toml
      index.ts       <-- Wraps WASM + legacy fallback?
      aabb.ts        <-- TS Wrapper around WASM AABB
      ...
    build/           <-- wasm-pack output
```

## 6. Fallback (Optional)
We can keep the TypeScript implementation as a fallback if WASM is not supported or for easier debugging, selected via a build flag or runtime check.

## Summary
By wrapping the WASM implementation in the existing TypeScript classes, we gain Rust's performance while keeping the "Data-Oriented" API that users are already using. The only user-facing change is the asynchronous initialization of the WASM module.
